# Numerical Analysis for Non-Linear Optimization | Module 1

## Best Samples, Antithetic Variables, and Moment Control Techniques

### Introduction

Monte Carlo methods play a fundamental role in **stochastic simulations**, **numerical optimization**, and **risk analysis**. This module explores advanced variance reduction techniques—**best samples**, **antithetic variables**, and **moment control techniques**—to enhance the efficiency and accuracy of Monte Carlo simulations.

---

### Best Samples: Enhancing Estimation Accuracy

The **best sample selection** technique improves the efficiency of Monte Carlo simulations by selecting sample points that minimize variance while maintaining unbiasedness.

#### Importance Sampling and Stratification

- **Importance Sampling**: Weights samples according to their probability density to reduce variance.
- **Stratified Sampling**: Divides the domain into strata and samples each stratum proportionally to ensure even coverage.

#### Quasi-Random Sequences

- **Low-discrepancy sequences** (e.g., Sobol, Halton) generate well-spaced samples.
- These sequences reduce **clustering** and improve integration efficiency compared to purely random samples.

---

### Antithetic Variables: Correlation for Variance Reduction

The **antithetic variable method** leverages negatively correlated sample pairs to reduce variance in Monte Carlo estimation.

#### Definition and Implementation

- Instead of generating independent samples $X_1, X_2, ..., X_n$, create **correlated pairs** $(X_i, X_i^*)$ such that $X_i^*$ is designed to counteract fluctuations in $X_i$.
- A common choice is $X_i^* = 1 - X_i$ for **uniform** distributions.

#### Example: Monte Carlo Estimation of $\pi$

```python
import numpy as np


def monte_carlo_pi_antithetic(n):
    u = np.random.random(n // 2)  # Generate half of the samples
    v = 1 - u  # Generate antithetic pairs
    x = np.concatenate((u, v))  # Combine samples
    y = np.random.random(n)  # Independent Y values
    inside_circle = (x**2 + y**2) <= 1
    return (np.sum(inside_circle) / n) * 4


print("Estimated Pi:", monte_carlo_pi_antithetic(1000000))
```

---

### Applications in Monte Carlo Simulations

These variance reduction techniques have broad applications across **finance**, **engineering**, and **scientific computing**. Below are implementations demonstrating their practical utility.

#### Estimating the Price of a European Call Option

```python
import numpy as np


def monte_carlo_european_call(S0, K, T, r, sigma, num_simulations):
    dt = T  # Single-step simulation
    U = np.random.normal(0, 1, num_simulations // 2)  # Standard normal samples
    V = -U  # Antithetic pairs

    Z = np.concatenate((U, V))  # Combine for variance reduction
    ST = S0 * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)
    payoff = np.maximum(ST - K, 0)
    discounted_payoff = np.exp(-r * T) * payoff
    return np.mean(discounted_payoff), np.std(discounted_payoff) / np.sqrt(
        num_simulations
    )


# Parameters
S0, K, T, r, sigma, num_simulations = 100, 100, 1, 0.05, 0.2, 100000
call_price, error = monte_carlo_european_call(S0, K, T, r, sigma, num_simulations)
print(f"European Call Option Price: {call_price:.4f} ± {error:.4f}")
```

### Conclusion

Applying **best samples**, **antithetic variables**, and **moment control techniques** significantly improves the efficiency of Monte Carlo methods. By **reducing variance**, these methods accelerate convergence, leading to **more reliable numerical solutions**.

### Exercises

#### Basic Implementations

1. Implement a Monte Carlo estimator for **normal expectations** using antithetic variables.
2. Compare variance reduction for **integration of $\sin(x)$** using stratified vs. simple sampling.

#### Advanced Applications

1. Apply moment control techniques to estimate **European call option prices**.
2. Modify Monte Carlo simulations for **stochastic differential equations (SDEs)** using **variance reduction methods**.
